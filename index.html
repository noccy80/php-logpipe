<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="LogPipe : Real-time monitoring of PHP application logs">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>LogPipe</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/noccy80/php-logpipe">View on GitHub</a>

          <h1 id="project_title">LogPipe</h1>
          <h2 id="project_tagline">Real-time monitoring of PHP application logs</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/noccy80/php-logpipe/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/noccy80/php-logpipe/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>For Developers</h3>

<p>LogPipe is an application and library to pipe out logs and debugging information from a running application. The library is used to send events (directly generated, generated from PHP errors and exceptions, and/or from Monolog) to the application which dumps the events.</p>
<p>LogPipe is designed to have a minimal impact on performance, and as such it will discard events if it encounters any issues while sending it.</p>
<h2 id="installing">Installing</h2>
<p>To install into a project using composer:</p>
<pre><code>$ composer require noccylabs/logpipe:@stable</code></pre>
<p>Install globally for using with shell scripts etc:</p>
<pre><code>$ composer global require noccylabs/logpipe:@stable</code></pre>
<h2 id="using-logpipe">Using LogPipe</h2>
<h3 id="using-with-monolog">Using with Monolog</h3>
<p>To use with Monolog, push a <code>LogPipeHandler</code> onto your <code>Logger</code>.</p>
<h3 id="using-with-symfony">Using with Symfony</h3>
<p>To use LogPipe with Symfony you only need to register the handler as a service so that it can be used with Monolog. This is preferably done in the <code>config_dev.yml</code> file. If there is a <code>services:</code> block, add the sections to it, otherwise create it:</p>
<pre><code>services:
    logpipe.handler:
        class:      NoccyLabs\LogPipe\Handler\LogPipeHandler
        arguments:  [ &quot;udp:127.0.0.1:6999&quot; ]</code></pre>
<p>Then define the handler in the same file. By doing it in <code>config_dev.yml</code>, your live environment will not use the LogPipe logger.</p>
<pre><code>monolog:
    handlers:
        ...
        logpipe:
            type:   service
            id:     logpipe.handler</code></pre>
<h3 id="using-elsewhere">Using elsewhere</h3>
<p>LogPipe can be set up to automatically log exceptions and errors:</p>
<pre><code>use NoccyLabs\LogPipe\Handler\ConsoleHandler;

$handler = new ConsoleHandler(&quot;tcp:127.0.0.1:9999:serializer=json&quot;);
$handler-&gt;setExceptionReporting(true);
$handler-&gt;setErrorReporting(true);</code></pre>
<p>You can also write events manually: <strong>(not implemented)</strong></p>
<pre><code>$handler-&gt;debug(&quot;This is a debug message!&quot;);
$handler-&gt;warning(&quot;Danger! Danger!&quot;);</code></pre>
<h3 id="dumping-events">Dumping events</h3>
<p>To start (listening for and) dumping events on the default port (<code>tcp:127.0.0.1:6601</code>) just use the <strong>dump</strong> command:</p>
<pre><code>$ bin/logpipe dump</code></pre>
<p>You can also specify to explicityly listen on a specific transport by providing it as an argument.</p>
<pre><code>$ bin/logpipe dump tcp:0.0.0.0:9999</code></pre>
<p>You can create some test events by using the <strong>test</strong> command in another terminal while the <strong>dump</strong> command is running:</p>
<pre><code>$ bin/logpipe test</code></pre>
<p>To save the log while viewing it, try using tee:</p>
<pre><code>$ bin/logpipe dump --no-ansi | tee messages.log</code></pre>
<p>You can also write events from the console, or from scripts:</p>
<pre><code>$ bin/logpipe write -c &quot;cron&quot; --error &quot;Setup failed&quot;</code></pre>
<p>Or pass events straight through from stdin:</p>
<pre><code>$ some_command | bin/logpipe log:pass </code></pre>
<h2 id="configuration-and-connection-strings">Configuration and connection strings</h2>
<p>The connection is set up using a simple connection string, consisting of the desired transport and any parameters needed to set it up separated by colon (<code>:</code>). Additional configuration can be added in HTML query-string style after the last parameter:</p>
<pre><code>tcp:127.0.0.1:12345:serializer=json</code></pre>
<h3 id="transports">Transports</h3>
<h4 id="udp">UDP</h4>
<pre><code>udp:&lt;host&gt;:&lt;port&gt;</code></pre>
<p>The default transport is over UDP port 6999. Messages sent over UDP are tagged with a 6-byte header specifying size and crc32 of the payload. Messages are serialized, transmitted, and once fully received and with a valid checksum unserialized and parsed. Note that due to how UDP works, if you spawn another dumper on the same port, the first one will stop receiving data without indicating an error.</p>
<h4 id="tcp">TCP</h4>
<p>The TCP transport works kinda like the UDP transport. However, since TCP is connection-oriented some complications may occur if no dumper is available. This needs more testing. It should however be able to handle bigger messages.</p>
<h4 id="pipe">Pipe</h4>
<pre><code>pipe:&lt;path&gt;</code></pre>
<p>The pipe transport is the default when no colon is found in the transport URI. Thus, <code>/var/run/foo.sock</code> will be internally translated to <code>pipe:/var/run/foo.sock</code>. The <em>listen()</em> method will create the named pipe and start listening for connections. Only use the pipe transport if you really have to. Concurrency might be an issue, as well as some unexpected blocking issues.</p>
<h3 id="serializers">Serializers</h3>
<p>What serializer is used is set in the sending transport. The serialization format is embedded in the message frame (together with checksum, size and flags) to that the appropriate unserializer can be invoked. The supported serializers are:</p>
<ul>
<li><code>php</code>: The built-in PHP serializer</li>
<li><code>json</code>: Uses Json to serialize the data</li>
<li><code>msgpack</code>: Like binary json, should result in smaller messages.</li>
</ul>
<p>To use a custom serializer, provide it with the endpoint URI: <code>udp:127.0.0.1:6999:serializer=msgpack</code> etc. As the policy is <em>fail and forget</em>, you will not receive any errors if the serializer is not supported. Calling on a non-existing serializer will throw an exception.</p>
<h2 id="the-interactive-dumper">The Interactive Dumper</h2>
<p>When launching the dumper in interactive mode (by passing <code>-i</code> or <code>--interactive</code>) some additional tools are available.</p>
<p>The last bunch of messages (normally 1000, but can be set with <code>-Cbuffer.size=N</code> on the command line or <code>:set buffer.size N</code> while in the dumper) are stored in a buffer. You can at any time search this buffer and dump any matches. To do this, just press slash (<code>/</code>) and start typing. The input will be parsed as a regular expression, so you can add modifiers to the end:</p>
<pre><code>/exception/i  &lt;- will perform a case independent match</code></pre>
<p>Currently the only supported command is <code>set</code>, but you can go ahead and invoke it by pressing colon (<code>:</code>) while in the dumper:</p>
<pre><code>:set                  &lt;- list all settings
:set buffer.size      &lt;- show the value of buffer.size
:set buffer.size 999  &lt;- set buffer size to 999</code></pre>
<h2 id="frequently-asked-questions-faq">Frequently Asked Questions (FAQ)</h2>
<p><strong>Q: I can't see all logged messages!!!</strong></p>
<p>LogPipe will fail quietly if anything goes wrong. This includes serialization of the log event, transport errors and more. This is done so that a problematic logger or transport will not cause the application being diagnosed to misbehave.</p>
<p><strong>Q: LogPipe is causing my application to misbehave!</strong></p>
<p>Please report this ASAP, unless you are able to fix the issue and commit a pull request. As previously mentioned, the strategy is <em>fail and forget</em>, meaning that ALL AND ANY errors that occur should be silently consumed, as to prevent the application from failing or misbehaving due to an auxillary logger.</p>
<p><strong>Q: The interactive mode doesn't work!</strong></p>
<p>LogPipe uses Stty to switch the terminal from line-buffered mode to raw character mode in order to implement custom readline functionality. In the long run, this will mean that you can enter commands or filter expressions while the log keep updating, but today it means that certain platforms may encounter issues.</p>
<h2 id="version-history">Version history</h2>
<pre><code>[!] Improvement  [*] Milestone  [+] New feature  [-] Removed feature

0.2.3   [*] The PipeV1Protocol header increased to 16 bytes.
        [+] Separated the standard dumper and the interactive dumper.
        [!] Added lots of phpdoc comments, and code cleanup.
0.2.2   [!] Increased message header size to prevent large messages from creating corrupted
            payloads.
0.2.1   [+] Implemented fifo-buffer to hold last N requests for quick searching.
        [+] Both Escape and Q can now be used to exit the dumper while in interactive mode.
        [*] TCP is now the default transport (tcp:127.0.0.1:6601)
0.2     [!] Data encapsulation stuff handled by PipeV1Protocol class.
        [!] Pipe transport considered fully functional.
0.1.5   [+] Added more unit tests.
0.1.3   [+] Added serializers.
        [!] Updated message- and transport structure.
        [!] Improved console commands.
0.1.2   [!] TCP transport considered functional.
        [+] Added support for using the envvar APP_ID, or the define() APP_ID to specify
            the prefix to use. Setting neither will use the hostname as app id.
0.1     [*] Initial release.</code></pre>
<h3 id="roadmap">Roadmap</h3>
<pre><code>1.0     [+] Full unit tests of application, command and code.
0.3     [+] Use noccylabs/console-input to provide the interactive shell.
        [+] Improve the interactive shell with on-the-fly filtering based on messages,
            levels and channels.</code></pre>


      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">LogPipe maintained by <a href="https://github.com/noccy80">noccy80</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
